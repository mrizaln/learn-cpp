#include <iostream>

//============[ algorithm and state ]============

// an algorithm is a finite sequenxe of instructions that can be followed to solve some
// problem or produce some useful result.

// here's a simple algorithm for generating a sequence of numbers where each successive
// number is incremented by 1:

    int plusOne(int start = 3)
    {
        static int state { start };     // only initialized the first time this function is called

        // generate the next number

        ++state;        // first we modify the state
        return state;   // then we use the new state to generate the next number in the sequence
    }

    int main_plusOne()
    {
        std::cout << plusOne() << '\n';
        std::cout << plusOne() << '\n';
        std::cout << plusOne() << '\n';

        return 0;
    }

// an algorithm is considere to be stateful if it retains some information accross all calls.
// conversely, a stateless algorithm does not store any information.




//============[ pseudo-random number generators (PRNGs) ]============

// to simulate randomness, programs typically use a pseudo-random number generator.
// a PRNG is an algorithm that generates a sequence of numbers whose properties simulate
// a sequence of random numbers.

// here's a simple PRNG:

    // for illustrative purpose only, don't use this
    unsigned int LCG16(unsigned int seed = 5323)    // our PRNG
    {
        static unsigned int state{ seed };

        // generate the next number
        // due to our use of large constants and overflow, it would be hard for someone to
        // casually predict what the next number is going to be from the previous one.

        state = 8253729 * state + 2396403;      // first we modify the state
        return state % 32768;                   // then we use the new state to generate the next number in the sequence
    }

    int main_LCG16()
    {
        // print 100 random numbers
        for (int count{ 1 }; count <= 100; ++count)
        {
            std::cout << LCG16() << '\t';

            if (count % 10 == 0)
                std::cout << '\n';
        }

        return 0;
    }




//============[ seeding a PRNG ]============

// the sequence of "random number" generated by a PRNG is not random at all.
// just like out plusOne() function, LCG16() is also deterministic.

// when a PRNG is instantiated, an initial value (or set of values) called a random seed
// (or seed for short) can be provoded to initialize the state of the PRNG.
// when a PRNG has been initialized with a seed, we say it has been seeded.

// most PRNGs that produce quality results use at least 16 bytes of state, if not significantly
// more.
// however, the size of the seed value can be smaller than rhe size of the state of the PRNG.
// when this happens, we say the PRNG has been underseeded.

// ideally, every bit in the state is initialized from a seed of equal size, and every bit
// in the seed has been independently determined somehow.
// however if a PRNG is underseeded, some number of bits in the state will need to be initialized
// from the same bits in the seed.
// if a PRNG is significantly underseeded, the quality of the random results the PRNG produces
// can be impacted.




//============[ what makes a good PRNG? ]============

// in order to be a good PRNG, the PRNG needs to exibit a number of preperties:
    // 1. the PRNG should generate each number with approximately the same probability.

    // 2. the method by which the next number in the sequence is generated shouldn't be
    //    predictable.

    // 3. the PRNG should have a good dimensional distribution of numbers.

    // 4. the PRNG should have a high period for all seeds.

    // 5. the PRNG should be efficient.




//============[ there are many different kinds of PRNG algorithms ]============

// over the years, many different kinds of PRNG algorithms have been developed:
//-----[ https://en.wikipedia.org/wiki/List_of_random_number_generators ]-----

// every PRNG algorithms has strenghts and weaknesses that might make it more or less
// suitable for a particular applications, so selecting the right alogorithm for your
// applicaion is important.

// many PRNGs are now are considered relatively poor by modern statndards -- and there's
// no reaseon to use a PRNGs that doesn't perform well when it's just as easy to use one
// that does.




//============[ randomization in C++ ]============

// the randomization capabilites in C++ are accessible via the   <random>   header of the
// standard library.
// within the random library, there are 6 PRNG families available for use (as of C++20)

/*---------------------------------------------------------------------------------------------------------------------------------------------------
    type name             | family                                    | period    | state size*   | performance   | quality   | should i use this?
-----------------------------------------------------------------------------------------------------------------------------------------------------
minstd_rand                 linear congruential generator               2^31        4 bytes         bad             awful       no
minstd_rand0                    

mt19937                     mersenne twister                            2^19937     2500 bytes      decent          decent      probably
mt19937_64                      

ranlux24                    subtract and carry                          10^171      96 bytes        awful           good        no
ranlux48                        

knuth_b                     shuffled linear congruential generator      2^31        1028 bytes      awful           bad         no

default_random_engine       any of above (implementation defined)       varies      varies          ?               ?           no

rand()                      linear congruential generator               2^31        4 bytes         bad             awful       no
---------------------------------------------------------------------------------------------------------------------------------------------------*/




//============[ so we should use mersenne twister, right? ]============

// probably.

// for most applications, mersenne twister is fine, both in terms of performace and quality.
// however, it's worth noting that by modern PRNG standards, mersenne twister is a bit outdated. 
// the biggest issue with mersenne twister is that its result can be predicted after seeing
// 624 generated numbers, making it non-suitable for any application that requires non-predictability.

// if you're developing an application that requires the highest quality random results
// (e.g a statistical simulation), the fastest results, or one where non-predictability is
// important (e.g. cryptography), you'll nee to use a 3rd party library.

// popular choices as the time of writing:
    // 1. the Xoshiro family [https://prng.di.unimi.it/]                | for non-cryptographic PRNGs.
    //    and Wyrand         [https://github.com/wangyi-fudan/wyhash]   |

    // 2. the Chacha family  [https://cr.yp.to/chacha.html]             | for cryptographic PRNGs


//=======================================================================================

int main()
{
    main_plusOne();
    main_LCG16();

    return 0;
}